#!/usr/bin/perl
#
use lib '/usr/local/netdisco';
use netdisco;

$use_files = 1;
netdisco::config("/usr/local/netdisco/netdisco.conf");

use Data::Dumper;

@roots = ();
$dev_regexp = 'sw-.*';
@onpath_cfg = ();
@offpath_cfg = ();
$ap_regexp = 'ap.*';
@ap_cfg = ();

open(CONFIG,"ndt.conf") || die "ndt.conf: $!\n";
while (<CONFIG>) {
	chomp;
	next if /^#/ || /^\s*$/;

	my($var, $value) = split(/:\s*/, $_, 2);
	if ($var eq 'dev_regexp') {
		$dev_regexp = $value;
		next;
	}

	if ($var eq 'root') {
		$roots[$#roots + 1] = $value;
		next;
	}
	if ($var eq 'onpath_cfg') {
		$onpath_cfg[$#onpath_cfg + 1] = $value;
		next;
	}
	if ($var eq 'offpath_cfg') {
		$offpath_cfg[$#offpath_cfg + 1] = $value;
		next;
	}
	if ($var eq 'ap_regexp') {
		$ap_regexp = $value;
		next;
	}
	if ($var eq 'ap_cfg') {
		$ap_cfg[$#ap_cfg + 1] = $value;
		next;
	}
	print "Couldn't parse $_\n";
}

# We need all of the ports on all of the devices that match
# the regexp.

$devices = netdisco::sql_rows( 'device d', [ '*' ] );
%porttype = ();
%remote = ();
foreach $device (@$devices) {
	$name = $device->{name};
	$name =~ s/\.meeting.ietf.org//;	# XXX
	if ($name =~ $dev_regexp) {
		$porttype{ $name } = {};
		$ports = netdisco::sql_rows( 'device_port p', [ '*' ],
						{ 'p.ip' => $device->{ip} } );
		foreach $port (@$ports) {
			$port_name = $port->{port};
			if ($port_name =~ /Ethernet/) {
				$porttype{ $name }{ $port_name } = 'unknown';
				$remote_id = $port->{remote_id};
				if ($remote_id) {
					$remote_id =~ s/\.meeting.ietf.org//;	#XXX
					$remote{ $name }{ $port_name } = $remote_id;
				}
			}
		}
	}
}

%rungraph = ();
foreach $root (@roots) {
	print $root, "\n";
	($dev, $port, $who) = split(/:/, $root);
	$porttype{ $dev }{ $port } = $who;
	if ($rungraph{ $dev }) {
		next;
	}
	$rungraph{ $dev } = 1;

	# Find the graphviz node name for $dev.
	$gvnode = qx/gvpr 'N [ \$.label == "$dev" ] { printf( "%s\n", \$.name ) }' graph_raw.dot/;
	chomp $gvnode;

	if ($gvnode eq '') {
		print "Can't find node in graph_raw.dot for $dev\n";
		exit(-1);
	}
	print "$dev -> $gvnode\n";
	$cmd = q/dijkstra -p / . $gvnode . q/ graph_raw.dot | gvpr 'N [ $.dist != "0.000" ] { node_t n; n = node( $G, $.prev ); printf( "%s %s\n", $.label, n.label ) }' |/;
	open( NODES, $cmd );
	while (<NODES>) {
		chomp;
		( $downlink, $uplink ) = split;
		foreach $port ( keys( %{$remote{ $downlink }} ) ) {
			if ($remote{ $downlink }{ $port } eq $uplink ) {
				$porttype{ $downlink }{ $port } = "uplink to $uplink for $who";
			}
		}
	}
}

#print Dumper( \%porttype );
#print Dumper( \%remote );
foreach $device (sort keys( %porttype )) {
	if ($use_files) {
		open( CFG, ">${device}.cfg" );
		print CFG "conf t\n";
	} else {
		*CFG = *STDOUT;
		print "\n\n$device configuration:\n!\n";
	}
	foreach $port (sort netdisco::sort_port keys( %{$porttype{ $device }} )) {
		print CFG "interface $port\n";
		if ( $remote{ $device }{ $port } ) {
			print CFG "   description $remote{ $device }{ $port }\n";
		}
		if ($porttype{ $device }{ $port } ne 'unknown') {
			print CFG "   ! $porttype{ $device }{ $port }\n";
			$cfg = \@onpath_cfg;
		} else {
			$cfg = \@offpath_cfg;
		}
		foreach $line (@$cfg) {
			print CFG "   $line\n";
		}
		if ( $remote{ $device }{ $port } =~ $ap_regexp ) {
			foreach $line (@ap_cfg) {
				print CFG "   $line\n";
			}
		}
	}
	print CFG "end\nwr\n";
}
